{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../projects/auth0-angular/src/useragent.ts","../../../projects/auth0-angular/src/lib/auth.client.ts","../../../projects/auth0-angular/src/lib/abstract-navigator.ts","../../../projects/auth0-angular/src/lib/auth.service.ts","../../../projects/auth0-angular/src/lib/auth.config.ts","../../../projects/auth0-angular/src/lib/auth.guard.ts","../../../projects/auth0-angular/src/lib/auth.module.ts","../../../projects/auth0-angular/src/lib/auth.interceptor.ts"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","this","n","v","op","TypeError","call","pop","length","push","Object","create","useragent","Auth0ClientFactory","createClient","config","redirectUri","clientId","maxAge","rest","s","p","prototype","hasOwnProperty","indexOf","getOwnPropertySymbols","i","propertyIsEnumerable","__rest","Auth0Client","assign","redirect_uri","client_id","max_age","auth0Client","name","version","Auth0ClientService","InjectionToken","AbstractNavigator","location","injector","router","get","Router","_a","navigateByUrl","url","_this","setTimeout","replaceState","Injectable","args","providedIn","Location","Injector","AuthService","navigator","isLoadingSubject$","BehaviorSubject","isAuthenticatedSubject$","errorSubject$","ReplaySubject","ngUnsubscribe$","Subject","isLoading$","asObservable","isAuthenticated$","pipe","filter","loading","distinctUntilChanged","concatMap","user$","authenticated","getUser","error$","shouldHandleCallback","switchMap","isCallback","iif","handleRedirectCallback","defer","checkSession","checkSessionOrCallback$","catchError","error","of","undefined","isAuthenticated","tap","takeUntil","subscribe","ngOnDestroy","complete","loginWithRedirect","options","from","loginWithPopup","_d","_c","_e","logout","localOnly","getAccessTokenSilently","client","getTokenSilently","getAccessTokenWithPopup","getTokenWithPopup","path","map","search","includes","target","_b","appState","isHttpInterceptorRouteConfig","def","uri","decorators","type","Inject","AuthConfigService","AuthGuard","auth","canLoad","route","segments","take","canActivate","state","redirectIfUnauthenticated","canActivateChild","childRoute","loggedIn","AuthModule","forRoot","defaultConfig","window","origin","ngModule","providers","provide","useValue","NgModule","AuthHttpInterceptor","intercept","req","httpInterceptor","allowedList","findMatchingRoute","pluck","token","clone","headers","set","handle","stripQueryFrom","substr","canAttachToken","request","testPrimitive","trim","startsWith","httpMethod","method","first"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export default { name: '@auth0/auth0-angular', version: '1.0.0' };\n","import { InjectionToken } from '@angular/core';\nimport { Auth0Client } from '@auth0/auth0-spa-js';\nimport { AuthConfig } from './auth.config';\nimport useragent from '../useragent';\n\nexport class Auth0ClientFactory {\n  static createClient(config: AuthConfig): Auth0Client {\n    const { redirectUri, clientId, maxAge, ...rest } = config;\n\n    return new Auth0Client({\n      redirect_uri: redirectUri,\n      client_id: clientId,\n      max_age: maxAge,\n      ...rest,\n      auth0Client: {\n        name: useragent.name,\n        version: useragent.version,\n      },\n    });\n  }\n}\n\nexport const Auth0ClientService = new InjectionToken<Auth0Client>(\n  'auth0.client'\n);\n","import { Injectable, Inject, Injector } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Location } from '@angular/common';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AbstractNavigator {\n  private readonly router: Router;\n\n  constructor(private location: Location, injector: Injector) {\n    try {\n      this.router = injector.get(Router);\n    } catch {}\n  }\n\n  /**\n   * Navigates to the specified url. The router will be used if one is available, otherwise it falls back\n   * to `window.history.replaceState`.\n   * @param url The url to navigate to\n   */\n  navigateByUrl(url: string): void {\n    if (this.router) {\n      setTimeout(() => {\n        this.router.navigateByUrl(url);\n      }, 0);\n\n      return;\n    }\n\n    this.location.replaceState(url);\n  }\n}\n","import { Injectable, Inject, OnDestroy } from '@angular/core';\n\nimport {\n  Auth0Client,\n  RedirectLoginOptions,\n  PopupLoginOptions,\n  PopupConfigOptions,\n  LogoutOptions,\n  GetTokenSilentlyOptions,\n  GetTokenWithPopupOptions,\n  RedirectLoginResult,\n} from '@auth0/auth0-spa-js';\n\nimport {\n  of,\n  from,\n  BehaviorSubject,\n  Subject,\n  Observable,\n  iif,\n  defer,\n  ReplaySubject,\n} from 'rxjs';\n\nimport {\n  concatMap,\n  tap,\n  map,\n  filter,\n  takeUntil,\n  distinctUntilChanged,\n  catchError,\n  switchMap,\n} from 'rxjs/operators';\n\nimport { Auth0ClientService } from './auth.client';\nimport { AbstractNavigator } from './abstract-navigator';\nimport { Location } from '@angular/common';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService implements OnDestroy {\n  private isLoadingSubject$ = new BehaviorSubject(true);\n  private isAuthenticatedSubject$ = new BehaviorSubject(false);\n  private errorSubject$ = new ReplaySubject<Error>(1);\n\n  // https://stackoverflow.com/a/41177163\n  private ngUnsubscribe$ = new Subject();\n\n  /**\n   * Emits boolean values indicating the loading state of the SDK.\n   */\n  readonly isLoading$ = this.isLoadingSubject$.asObservable();\n\n  /**\n   * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n   * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n   */\n  readonly isAuthenticated$ = this.isLoading$.pipe(\n    filter((loading) => !loading),\n    distinctUntilChanged(),\n    concatMap(() => this.isAuthenticatedSubject$)\n  );\n\n  /**\n   * Emits details about the authenticated user when `isAuthenticated$` is `true`.\n   */\n  readonly user$ = this.isAuthenticated$.pipe(\n    filter((authenticated) => authenticated),\n    distinctUntilChanged(),\n    concatMap(() => this.auth0Client.getUser())\n  );\n\n  /**\n   * Emits errors that occur during login, or when checking for an active session on startup.\n   */\n  readonly error$ = this.errorSubject$.asObservable();\n\n  constructor(\n    @Inject(Auth0ClientService) private auth0Client: Auth0Client,\n    private location: Location,\n    private navigator: AbstractNavigator\n  ) {\n    const checkSessionOrCallback$ = (isCallback: boolean) =>\n      iif(\n        () => isCallback,\n        this.handleRedirectCallback(),\n        defer(() => this.auth0Client.checkSession())\n      );\n\n    this.shouldHandleCallback()\n      .pipe(\n        switchMap((isCallback) =>\n          checkSessionOrCallback$(isCallback).pipe(\n            catchError((error) => {\n              this.errorSubject$.next(error);\n              this.navigator.navigateByUrl('/');\n              return of(undefined);\n            })\n          )\n        ),\n        concatMap(() => this.auth0Client.isAuthenticated()),\n        tap((authenticated) => {\n          this.isAuthenticatedSubject$.next(authenticated);\n          this.isLoadingSubject$.next(false);\n        }),\n        takeUntil(this.ngUnsubscribe$)\n      )\n      .subscribe();\n  }\n\n  /**\n   * Called when the service is destroyed\n   */\n  ngOnDestroy(): void {\n    // https://stackoverflow.com/a/41177163\n    this.ngUnsubscribe$.next();\n    this.ngUnsubscribe$.complete();\n  }\n\n  /**\n   * ```js\n   * loginWithRedirect(options);\n   * ```\n   *\n   * Performs a redirect to `/authorize` using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated.\n   *\n   * @param options The login options\n   */\n  loginWithRedirect(options?: RedirectLoginOptions): Observable<void> {\n    return from(this.auth0Client.loginWithRedirect(options));\n  }\n\n  /**\n   * ```js\n   * await loginWithPopup(options);\n   * ```\n   *\n   * Opens a popup with the `/authorize` URL using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated. If the response is successful,\n   * results will be valid according to their expiration times.\n   *\n   * IMPORTANT: This method has to be called from an event handler\n   * that was started by the user like a button click, for example,\n   * otherwise the popup will be blocked in most browsers.\n   *\n   * @param options The login options\n   * @param config Configuration for the popup window\n   */\n  loginWithPopup(\n    options?: PopupLoginOptions,\n    config?: PopupConfigOptions\n  ): Observable<void> {\n    return from(\n      this.auth0Client.loginWithPopup(options, config).then(async () => {\n        this.isAuthenticatedSubject$.next(\n          await this.auth0Client.isAuthenticated()\n        );\n      })\n    );\n  }\n\n  /**\n   * ```js\n   * logout();\n   * ```\n   *\n   * Clears the application session and performs a redirect to `/v2/logout`, using\n   * the parameters provided as arguments, to clear the Auth0 session.\n   * If the `federated` option is specified it also clears the Identity Provider session.\n   * If the `localOnly` option is specified, it only clears the application session.\n   * It is invalid to set both the `federated` and `localOnly` options to `true`,\n   * and an error will be thrown if you do.\n   * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).\n   *\n   * @param options The logout options\n   */\n  logout(options?: LogoutOptions): void {\n    this.auth0Client.logout(options);\n\n    if (options?.localOnly) {\n      this.isAuthenticatedSubject$.next(false);\n    }\n  }\n\n  /**\n   * ```js\n   * getAccessTokenSilently(options).subscribe(token => ...)\n   * ```\n   *\n   * If there's a valid token stored, return it. Otherwise, opens an\n   * iframe with the `/authorize` URL using the parameters provided\n   * as arguments. Random and secure `state` and `nonce` parameters\n   * will be auto-generated. If the response is successful, results\n   * will be valid according to their expiration times.\n   *\n   * If refresh tokens are used, the token endpoint is called directly with the\n   * 'refresh_token' grant. If no refresh token is available to make this call,\n   * the SDK falls back to using an iframe to the '/authorize' URL.\n   *\n   * This method may use a web worker to perform the token call if the in-memory\n   * cache is used.\n   *\n   * If an `audience` value is given to this function, the SDK always falls\n   * back to using an iframe to make the token exchange.\n   *\n   * Note that in all cases, falling back to an iframe requires access to\n   * the `auth0` cookie, and thus will not work in browsers that block third-party\n   * cookies by default (Safari, Brave, etc).\n   *\n   * @param options The options for configuring the token fetch.\n   */\n  getAccessTokenSilently(\n    options?: GetTokenSilentlyOptions\n  ): Observable<string> {\n    return of(this.auth0Client).pipe(\n      concatMap((client) => client.getTokenSilently(options))\n    );\n  }\n\n  /**\n   * ```js\n   * getTokenWithPopup(options).subscribe(token => ...)\n   * ```\n   *\n   * Get an access token interactively.\n   *\n   * Opens a popup with the `/authorize` URL using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated. If the response is successful,\n   * results will be valid according to their expiration times.\n   */\n  getAccessTokenWithPopup(\n    options?: GetTokenWithPopupOptions\n  ): Observable<string> {\n    return of(this.auth0Client).pipe(\n      concatMap((client) => client.getTokenWithPopup(options))\n    );\n  }\n\n  private shouldHandleCallback(): Observable<boolean> {\n    return of(this.location.path()).pipe(\n      map(\n        (search) =>\n          (search.includes('code=') || search.includes('error=')) &&\n          search.includes('state=')\n      )\n    );\n  }\n\n  private handleRedirectCallback(): Observable<RedirectLoginResult> {\n    return defer(() => this.auth0Client.handleRedirectCallback()).pipe(\n      tap((result) => {\n        const target = result?.appState?.target ?? '/';\n        this.navigator.navigateByUrl(target);\n      })\n    );\n  }\n}\n","import { CacheLocation, GetTokenSilentlyOptions } from '@auth0/auth0-spa-js';\nimport { InjectionToken } from '@angular/core';\n\n/**\n * Defines a common set of HTTP methods.\n */\nexport const enum HttpMethod {\n  Get = 'GET',\n  Post = 'POST',\n  Put = 'PUT',\n  Patch = 'PATCH',\n  Delete = 'DELETE',\n  Head = 'HEAD',\n}\n\n/**\n * Defines the type for a route config entry. Can either be:\n *\n * - an object of type HttpInterceptorConfig\n * - a string\n */\nexport type ApiRouteDefinition = HttpInterceptorRouteConfig | string;\n\n/**\n * A custom type guard to help identify route definitions that are actually HttpInterceptorRouteConfig types.\n * @param def The route definition type\n */\nexport function isHttpInterceptorRouteConfig(\n  def: ApiRouteDefinition\n): def is HttpInterceptorRouteConfig {\n  return (def as HttpInterceptorRouteConfig).uri !== undefined;\n}\n\n/**\n * Configuration for the HttpInterceptor\n */\nexport interface HttpInterceptorConfig {\n  allowedList: ApiRouteDefinition[];\n}\n\n/**\n * Configuration for a single interceptor route\n */\nexport interface HttpInterceptorRouteConfig {\n  /**\n   * The URL to test, by supplying the URL to match.\n   * If `test` is a match for the current request path from the HTTP client, then\n   * an access token is attached to the request in the\n   *  [\"Authorization\" header](https://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-20#section-2.1).\n   *\n   * If the test does not pass, the request proceeds without the access token attached.\n   *\n   * A wildcard character can be used to match only the start of the URL.\n   *\n   * @usagenotes\n   *\n   * '/api' - exactly match the route /api\n   * '/api/*' - match any route that starts with /api/\n   */\n  uri: string;\n\n  /**\n   * The options that are passed to the SDK when retrieving the\n   * access token to attach to the outgoing request.\n   */\n  tokenOptions?: GetTokenSilentlyOptions;\n\n  /**\n   * The HTTP method to match on. If specified, the HTTP method of\n   * the outgoing request will be checked against this. If there is no match, the\n   * Authorization header is not attached.\n   *\n   * The HTTP method name is case-sensitive.\n   */\n  httpMethod?: HttpMethod | string;\n}\n\n/**\n * Configuration for the authentication service\n */\nexport interface AuthConfig {\n  /**\n   * Your Auth0 account domain such as `'example.auth0.com'`,\n   * `'example.eu.auth0.com'` or , `'example.mycompany.com'`\n   * (when using [custom domains](https://auth0.com/docs/custom-domains))\n   */\n  domain: string;\n\n  /**\n   * The issuer to be used for validation of JWTs, optionally defaults to the domain above\n   */\n  issuer?: string;\n\n  /**\n   * The Client ID found on your Application settings page\n   */\n  clientId: string;\n\n  /**\n   * The default URL where Auth0 will redirect your browser to with\n   * the authentication result. It must be added to the\n   * \"Allowed Callback URLs\" field in your Auth0 Application's\n   * settings. If not provided here, it should be provided in the other\n   * methods that provide authentication.\n   */\n  redirectUri?: string;\n\n  /**\n   * The value in seconds used to account for clock skew in JWT expirations.\n   * Typically, this value is no more than a minute or two at maximum.\n   * Defaults to 60s.\n   */\n  leeway?: number;\n\n  /**\n   * The location to use when storing cache data. Valid values are `memory` or `localstorage`.\n   * The default setting is `memory`.\n   */\n  cacheLocation?: CacheLocation;\n\n  /**\n   * If true, refresh tokens are used to fetch new access tokens from the Auth0 server.\n   * If false, the legacy technique of using a hidden iframe and the `authorization_code` grant with `prompt=none` is used.\n   * The default setting is `false`.\n   *\n   * **Note**: Use of refresh tokens must be enabled by an administrator on your Auth0 client application.\n   */\n  useRefreshTokens?: boolean;\n\n  /**\n   * A maximum number of seconds to wait before declaring background calls to /authorize as failed for timeout\n   * Defaults to 60s.\n   */\n  authorizeTimeoutInSeconds?: number;\n\n  /**\n   * Changes to recommended defaults, like defaultScope\n   */\n  advancedOptions?: {\n    /**\n     * The default scope to be included with all requests.\n     * If not provided, 'openid profile email' is used. This can be set to `null` in order to effectively remove the default scopes.\n     *\n     * Note: The `openid` scope is **always applied** regardless of this setting.\n     */\n    defaultScope?: string;\n  };\n\n  /**\n   * Maximum allowable elapsed time (in seconds) since authentication.\n   * If the last time the user authenticated is greater than this value,\n   * the user must be reauthenticated.\n   */\n  maxAge?: string | number;\n\n  /**\n   * The default scope to be used on authentication requests.\n   * The defaultScope defined in the Auth0Client is included\n   * along with this scope\n   */\n  scope?: string;\n\n  /**\n   * The default audience to be used for requesting API access.\n   */\n  audience?: string;\n\n  /**\n   * Configuration for the built-in Http Interceptor, used for\n   * automatically attaching access tokens.\n   */\n  httpInterceptor?: HttpInterceptorConfig;\n\n  /**\n   * If you need to send custom parameters to the Authorization Server,\n   * make sure to use the original parameter name.\n   */\n  [key: string]: any;\n}\n\n/**\n * Injection token for accessing configuration.\n *\n * @usageNotes\n *\n * Use the `Inject` decorator to access the configuration from a service or component:\n *\n * ```\n * class MyService(@Inject(AuthConfigService) config: AuthConfig) {}\n * ```\n */\nexport const AuthConfigService = new InjectionToken<AuthConfig>(\n  'auth0-angular.config'\n);\n","import { Injectable } from '@angular/core';\nimport {\n  ActivatedRouteSnapshot,\n  RouterStateSnapshot,\n  CanActivate,\n  CanLoad,\n  Route,\n  UrlSegment,\n  CanActivateChild,\n} from '@angular/router';\nimport { Observable, of } from 'rxjs';\nimport { tap, take } from 'rxjs/operators';\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthGuard implements CanActivate, CanLoad, CanActivateChild {\n  constructor(private auth: AuthService) {}\n\n  canLoad(route: Route, segments: UrlSegment[]): Observable<boolean> {\n    return this.auth.isAuthenticated$.pipe(take(1));\n  }\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.redirectIfUnauthenticated(state);\n  }\n\n  canActivateChild(\n    childRoute: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.redirectIfUnauthenticated(state);\n  }\n\n  private redirectIfUnauthenticated(\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.auth.isAuthenticated$.pipe(\n      tap((loggedIn) => {\n        if (!loggedIn) {\n          this.auth.loginWithRedirect({ appState: { target: state.url } });\n        } else {\n          return of(true);\n        }\n      })\n    );\n  }\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { AuthService } from './auth.service';\nimport { AuthConfig, AuthConfigService } from './auth.config';\nimport { Auth0ClientService, Auth0ClientFactory } from './auth.client';\nimport { AuthGuard } from './auth.guard';\n\n@NgModule()\nexport class AuthModule {\n  static forRoot(config: AuthConfig): ModuleWithProviders<AuthModule> {\n    const defaultConfig: AuthConfig = {\n      redirectUri: window.location.origin,\n      ...config,\n    };\n\n    return {\n      ngModule: AuthModule,\n      providers: [\n        AuthService,\n        AuthGuard,\n        { provide: AuthConfigService, useValue: defaultConfig },\n        {\n          provide: Auth0ClientService,\n          useValue: Auth0ClientFactory.createClient(defaultConfig),\n        },\n      ],\n    };\n  }\n}\n","import {\n  HttpInterceptor,\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n} from '@angular/common/http';\n\nimport { Observable, from, of, iif } from 'rxjs';\nimport { Injectable, Inject } from '@angular/core';\n\nimport {\n  AuthConfig,\n  AuthConfigService,\n  HttpInterceptorRouteConfig,\n  ApiRouteDefinition,\n  isHttpInterceptorRouteConfig,\n} from './auth.config';\n\nimport { Auth0ClientService } from './auth.client';\nimport { Auth0Client } from '@auth0/auth0-spa-js';\nimport { switchMap, first, concatMap, pluck } from 'rxjs/operators';\n\n@Injectable()\nexport class AuthHttpInterceptor implements HttpInterceptor {\n  constructor(\n    @Inject(AuthConfigService) private config: AuthConfig,\n    @Inject(Auth0ClientService) private auth0Client: Auth0Client\n  ) {}\n\n  intercept(\n    req: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    if (!this.config.httpInterceptor?.allowedList) {\n      return next.handle(req);\n    }\n\n    return this.findMatchingRoute(req).pipe(\n      concatMap((route) =>\n        iif(\n          // Check if a route was matched\n          () => route !== null,\n          // If we have a matching route, call getTokenSilently and attach the token to the\n          // outgoing request\n          of(route).pipe(\n            pluck('tokenOptions'),\n            concatMap((options) => this.auth0Client.getTokenSilently(options)),\n            switchMap((token: string) => {\n              // Clone the request and attach the bearer token\n              const clone = req.clone({\n                headers: req.headers.set('Authorization', `Bearer ${token}`),\n              });\n\n              return next.handle(clone);\n            })\n          ),\n          // If the URI being called was not found in our httpInterceptor config, simply\n          // pass the request through without attaching a token\n          next.handle(req)\n        )\n      )\n    );\n  }\n\n  /**\n   * Strips the query and fragment from the given uri\n   * @param uri The uri to remove the query and fragment from\n   */\n  private stripQueryFrom(uri: string): string {\n    if (uri.indexOf('?') > -1) {\n      uri = uri.substr(0, uri.indexOf('?'));\n    }\n\n    if (uri.indexOf('#') > -1) {\n      uri = uri.substr(0, uri.indexOf('#'));\n    }\n\n    return uri;\n  }\n\n  /**\n   * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against\n   * the interceptor route configuration.\n   * @param route The route to test\n   * @param request The HTTP request\n   */\n  private canAttachToken(\n    route: ApiRouteDefinition,\n    request: HttpRequest<any>\n  ): boolean {\n    const testPrimitive = (value: string) => {\n      if (value) {\n        value.trim();\n      }\n\n      if (!value) {\n        return false;\n      }\n\n      const requestPath = this.stripQueryFrom(request.url);\n\n      if (value === requestPath) {\n        return true;\n      }\n\n      // If the URL ends with an asterisk, match using startsWith.\n      if (\n        value.indexOf('*') === value.length - 1 &&\n        request.url.startsWith(value.substr(0, value.length - 1))\n      ) {\n        return true;\n      }\n    };\n\n    if (isHttpInterceptorRouteConfig(route)) {\n      if (route.httpMethod && route.httpMethod !== request.method) {\n        return false;\n      }\n\n      return testPrimitive(route.uri);\n    }\n\n    return testPrimitive(route);\n  }\n\n  /**\n   * Tries to match a route from the SDK configuration to the HTTP request.\n   * If a match is found, the route configuration is returned.\n   * @param request The Http request\n   */\n  private findMatchingRoute(\n    request: HttpRequest<any>\n  ): Observable<HttpInterceptorRouteConfig> {\n    return from(this.config.httpInterceptor.allowedList).pipe(\n      first((route) => this.canAttachToken(route, request), null)\n    );\n  }\n}\n"]}