import { __rest, __awaiter } from 'tslib';
import { InjectionToken, ɵɵdefineInjectable, ɵɵinject, INJECTOR, Injectable, Injector, Inject, NgModule } from '@angular/core';
import { Auth0Client } from '@auth0/auth0-spa-js';
import { BehaviorSubject, ReplaySubject, Subject, iif, defer, of, from } from 'rxjs';
import { filter, distinctUntilChanged, concatMap, switchMap, catchError, tap, takeUntil, map, take, pluck, first } from 'rxjs/operators';
import { Router } from '@angular/router';
import { Location } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@auth0/auth0-spa-js';
var useragent = { name: '@auth0/auth0-angular', version: '1.0.0' };

class Auth0ClientFactory {
    static createClient(config) {
        const { redirectUri, clientId, maxAge } = config, rest = __rest(config, ["redirectUri", "clientId", "maxAge"]);
        return new Auth0Client(Object.assign(Object.assign({ redirect_uri: redirectUri, client_id: clientId, max_age: maxAge }, rest), { auth0Client: {
                name: useragent.name,
                version: useragent.version,
            } }));
    }
}
const Auth0ClientService = new InjectionToken('auth0.client');

class AbstractNavigator {
    constructor(location, injector) {
        this.location = location;
        try {
            this.router = injector.get(Router);
        }
        catch (_a) { }
    }
    /**
     * Navigates to the specified url. The router will be used if one is available, otherwise it falls back
     * to `window.history.replaceState`.
     * @param url The url to navigate to
     */
    navigateByUrl(url) {
        if (this.router) {
            setTimeout(() => {
                this.router.navigateByUrl(url);
            }, 0);
            return;
        }
        this.location.replaceState(url);
    }
}
AbstractNavigator.ɵfac = function AbstractNavigator_Factory(t) { return new (t || AbstractNavigator)(ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
AbstractNavigator.ɵprov = ɵɵdefineInjectable({ factory: function AbstractNavigator_Factory() { return new AbstractNavigator(ɵɵinject(Location), ɵɵinject(INJECTOR)); }, token: AbstractNavigator, providedIn: "root" });
AbstractNavigator.ctorParameters = () => [
    { type: Location },
    { type: Injector }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AbstractNavigator, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.Location }, { type: ɵngcc0.Injector }]; }, null); })();

class AuthService {
    constructor(auth0Client, location, navigator) {
        this.auth0Client = auth0Client;
        this.location = location;
        this.navigator = navigator;
        this.isLoadingSubject$ = new BehaviorSubject(true);
        this.isAuthenticatedSubject$ = new BehaviorSubject(false);
        this.errorSubject$ = new ReplaySubject(1);
        // https://stackoverflow.com/a/41177163
        this.ngUnsubscribe$ = new Subject();
        /**
         * Emits boolean values indicating the loading state of the SDK.
         */
        this.isLoading$ = this.isLoadingSubject$.asObservable();
        /**
         * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.
         * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.
         */
        this.isAuthenticated$ = this.isLoading$.pipe(filter((loading) => !loading), distinctUntilChanged(), concatMap(() => this.isAuthenticatedSubject$));
        /**
         * Emits details about the authenticated user when `isAuthenticated$` is `true`.
         */
        this.user$ = this.isAuthenticated$.pipe(filter((authenticated) => authenticated), distinctUntilChanged(), concatMap(() => this.auth0Client.getUser()));
        /**
         * Emits errors that occur during login, or when checking for an active session on startup.
         */
        this.error$ = this.errorSubject$.asObservable();
        const checkSessionOrCallback$ = (isCallback) => iif(() => isCallback, this.handleRedirectCallback(), defer(() => this.auth0Client.checkSession()));
        this.shouldHandleCallback()
            .pipe(switchMap((isCallback) => checkSessionOrCallback$(isCallback).pipe(catchError((error) => {
            this.errorSubject$.next(error);
            this.navigator.navigateByUrl('/');
            return of(undefined);
        }))), concatMap(() => this.auth0Client.isAuthenticated()), tap((authenticated) => {
            this.isAuthenticatedSubject$.next(authenticated);
            this.isLoadingSubject$.next(false);
        }), takeUntil(this.ngUnsubscribe$))
            .subscribe();
    }
    /**
     * Called when the service is destroyed
     */
    ngOnDestroy() {
        // https://stackoverflow.com/a/41177163
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
    }
    /**
     * ```js
     * loginWithRedirect(options);
     * ```
     *
     * Performs a redirect to `/authorize` using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated.
     *
     * @param options The login options
     */
    loginWithRedirect(options) {
        return from(this.auth0Client.loginWithRedirect(options));
    }
    /**
     * ```js
     * await loginWithPopup(options);
     * ```
     *
     * Opens a popup with the `/authorize` URL using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated. If the response is successful,
     * results will be valid according to their expiration times.
     *
     * IMPORTANT: This method has to be called from an event handler
     * that was started by the user like a button click, for example,
     * otherwise the popup will be blocked in most browsers.
     *
     * @param options The login options
     * @param config Configuration for the popup window
     */
    loginWithPopup(options, config) {
        return from(this.auth0Client.loginWithPopup(options, config).then(() => __awaiter(this, void 0, void 0, function* () {
            this.isAuthenticatedSubject$.next(yield this.auth0Client.isAuthenticated());
        })));
    }
    /**
     * ```js
     * logout();
     * ```
     *
     * Clears the application session and performs a redirect to `/v2/logout`, using
     * the parameters provided as arguments, to clear the Auth0 session.
     * If the `federated` option is specified it also clears the Identity Provider session.
     * If the `localOnly` option is specified, it only clears the application session.
     * It is invalid to set both the `federated` and `localOnly` options to `true`,
     * and an error will be thrown if you do.
     * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).
     *
     * @param options The logout options
     */
    logout(options) {
        this.auth0Client.logout(options);
        if (options === null || options === void 0 ? void 0 : options.localOnly) {
            this.isAuthenticatedSubject$.next(false);
        }
    }
    /**
     * ```js
     * getAccessTokenSilently(options).subscribe(token => ...)
     * ```
     *
     * If there's a valid token stored, return it. Otherwise, opens an
     * iframe with the `/authorize` URL using the parameters provided
     * as arguments. Random and secure `state` and `nonce` parameters
     * will be auto-generated. If the response is successful, results
     * will be valid according to their expiration times.
     *
     * If refresh tokens are used, the token endpoint is called directly with the
     * 'refresh_token' grant. If no refresh token is available to make this call,
     * the SDK falls back to using an iframe to the '/authorize' URL.
     *
     * This method may use a web worker to perform the token call if the in-memory
     * cache is used.
     *
     * If an `audience` value is given to this function, the SDK always falls
     * back to using an iframe to make the token exchange.
     *
     * Note that in all cases, falling back to an iframe requires access to
     * the `auth0` cookie, and thus will not work in browsers that block third-party
     * cookies by default (Safari, Brave, etc).
     *
     * @param options The options for configuring the token fetch.
     */
    getAccessTokenSilently(options) {
        return of(this.auth0Client).pipe(concatMap((client) => client.getTokenSilently(options)));
    }
    /**
     * ```js
     * getTokenWithPopup(options).subscribe(token => ...)
     * ```
     *
     * Get an access token interactively.
     *
     * Opens a popup with the `/authorize` URL using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated. If the response is successful,
     * results will be valid according to their expiration times.
     */
    getAccessTokenWithPopup(options) {
        return of(this.auth0Client).pipe(concatMap((client) => client.getTokenWithPopup(options)));
    }
    shouldHandleCallback() {
        return of(this.location.path()).pipe(map((search) => (search.includes('code=') || search.includes('error=')) &&
            search.includes('state=')));
    }
    handleRedirectCallback() {
        return defer(() => this.auth0Client.handleRedirectCallback()).pipe(tap((result) => {
            var _a, _b;
            const target = (_b = (_a = result === null || result === void 0 ? void 0 : result.appState) === null || _a === void 0 ? void 0 : _a.target) !== null && _b !== void 0 ? _b : '/';
            this.navigator.navigateByUrl(target);
        }));
    }
}
AuthService.ɵfac = function AuthService_Factory(t) { return new (t || AuthService)(ɵngcc0.ɵɵinject(Auth0ClientService), ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(AbstractNavigator)); };
AuthService.ɵprov = ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthService(ɵɵinject(Auth0ClientService), ɵɵinject(Location), ɵɵinject(AbstractNavigator)); }, token: AuthService, providedIn: "root" });
AuthService.ctorParameters = () => [
    { type: Auth0Client, decorators: [{ type: Inject, args: [Auth0ClientService,] }] },
    { type: Location },
    { type: AbstractNavigator }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AuthService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc2.Auth0Client, decorators: [{
                type: Inject,
                args: [Auth0ClientService]
            }] }, { type: ɵngcc1.Location }, { type: AbstractNavigator }]; }, null); })();

/**
 * A custom type guard to help identify route definitions that are actually HttpInterceptorRouteConfig types.
 * @param def The route definition type
 */
function isHttpInterceptorRouteConfig(def) {
    return def.uri !== undefined;
}
/**
 * Injection token for accessing configuration.
 *
 * @usageNotes
 *
 * Use the `Inject` decorator to access the configuration from a service or component:
 *
 * ```
 * class MyService(@Inject(AuthConfigService) config: AuthConfig) {}
 * ```
 */
const AuthConfigService = new InjectionToken('auth0-angular.config');

class AuthGuard {
    constructor(auth) {
        this.auth = auth;
    }
    canLoad(route, segments) {
        return this.auth.isAuthenticated$.pipe(take(1));
    }
    canActivate(next, state) {
        return this.redirectIfUnauthenticated(state);
    }
    canActivateChild(childRoute, state) {
        return this.redirectIfUnauthenticated(state);
    }
    redirectIfUnauthenticated(state) {
        return this.auth.isAuthenticated$.pipe(tap((loggedIn) => {
            if (!loggedIn) {
                this.auth.loginWithRedirect({ appState: { target: state.url } });
            }
            else {
                return of(true);
            }
        }));
    }
}
AuthGuard.ɵfac = function AuthGuard_Factory(t) { return new (t || AuthGuard)(ɵngcc0.ɵɵinject(AuthService)); };
AuthGuard.ɵprov = ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(ɵɵinject(AuthService)); }, token: AuthGuard, providedIn: "root" });
AuthGuard.ctorParameters = () => [
    { type: AuthService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AuthGuard, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: AuthService }]; }, null); })();

class AuthModule {
    static forRoot(config) {
        const defaultConfig = Object.assign({ redirectUri: window.location.origin }, config);
        return {
            ngModule: AuthModule,
            providers: [
                AuthService,
                AuthGuard,
                { provide: AuthConfigService, useValue: defaultConfig },
                {
                    provide: Auth0ClientService,
                    useValue: Auth0ClientFactory.createClient(defaultConfig),
                },
            ],
        };
    }
}
AuthModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AuthModule });
AuthModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AuthModule_Factory(t) { return new (t || AuthModule)(); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AuthModule, [{
        type: NgModule
    }], null, null); })();

class AuthHttpInterceptor {
    constructor(config, auth0Client) {
        this.config = config;
        this.auth0Client = auth0Client;
    }
    intercept(req, next) {
        var _a;
        if (!((_a = this.config.httpInterceptor) === null || _a === void 0 ? void 0 : _a.allowedList)) {
            return next.handle(req);
        }
        return this.findMatchingRoute(req).pipe(concatMap((route) => iif(
        // Check if a route was matched
        () => route !== null, 
        // If we have a matching route, call getTokenSilently and attach the token to the
        // outgoing request
        of(route).pipe(pluck('tokenOptions'), concatMap((options) => this.auth0Client.getTokenSilently(options)), switchMap((token) => {
            // Clone the request and attach the bearer token
            const clone = req.clone({
                headers: req.headers.set('Authorization', `Bearer ${token}`),
            });
            return next.handle(clone);
        })), 
        // If the URI being called was not found in our httpInterceptor config, simply
        // pass the request through without attaching a token
        next.handle(req))));
    }
    /**
     * Strips the query and fragment from the given uri
     * @param uri The uri to remove the query and fragment from
     */
    stripQueryFrom(uri) {
        if (uri.indexOf('?') > -1) {
            uri = uri.substr(0, uri.indexOf('?'));
        }
        if (uri.indexOf('#') > -1) {
            uri = uri.substr(0, uri.indexOf('#'));
        }
        return uri;
    }
    /**
     * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against
     * the interceptor route configuration.
     * @param route The route to test
     * @param request The HTTP request
     */
    canAttachToken(route, request) {
        const testPrimitive = (value) => {
            if (value) {
                value.trim();
            }
            if (!value) {
                return false;
            }
            const requestPath = this.stripQueryFrom(request.url);
            if (value === requestPath) {
                return true;
            }
            // If the URL ends with an asterisk, match using startsWith.
            if (value.indexOf('*') === value.length - 1 &&
                request.url.startsWith(value.substr(0, value.length - 1))) {
                return true;
            }
        };
        if (isHttpInterceptorRouteConfig(route)) {
            if (route.httpMethod && route.httpMethod !== request.method) {
                return false;
            }
            return testPrimitive(route.uri);
        }
        return testPrimitive(route);
    }
    /**
     * Tries to match a route from the SDK configuration to the HTTP request.
     * If a match is found, the route configuration is returned.
     * @param request The Http request
     */
    findMatchingRoute(request) {
        return from(this.config.httpInterceptor.allowedList).pipe(first((route) => this.canAttachToken(route, request), null));
    }
}
AuthHttpInterceptor.ɵfac = function AuthHttpInterceptor_Factory(t) { return new (t || AuthHttpInterceptor)(ɵngcc0.ɵɵinject(AuthConfigService), ɵngcc0.ɵɵinject(Auth0ClientService)); };
AuthHttpInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AuthHttpInterceptor, factory: AuthHttpInterceptor.ɵfac });
AuthHttpInterceptor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [AuthConfigService,] }] },
    { type: Auth0Client, decorators: [{ type: Inject, args: [Auth0ClientService,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AuthHttpInterceptor, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [AuthConfigService]
            }] }, { type: ɵngcc2.Auth0Client, decorators: [{
                type: Inject,
                args: [Auth0ClientService]
            }] }]; }, null); })();

/*
 * Public API Surface of auth0-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AuthConfigService, AuthGuard, AuthHttpInterceptor, AuthModule, AuthService, isHttpInterceptorRouteConfig, Auth0ClientService as ɵa, AbstractNavigator as ɵb };

//# sourceMappingURL=auth0-auth0-angular.js.map